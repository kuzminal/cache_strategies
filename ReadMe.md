# Реализация алгоритмов кэширования

В этом проекте реализованы два популярных алгоритма кэширования на языке Go: LRU (Least Recently Used) и LFU (Least Frequently Used).

## Структура проекта

```
├── cmd/
│   └── app/
│       └── main.go
├── pkg/
│   └── cache/
│       ├── cache.go
│       ├── lru/
│       │   ├── lru_cache.go
│       │   └── lru_cache_test.go
│       └── lfu/
│           ├── lfu_cache.go
│           └── lfu_cache_test.go
├── go.mod
├── go.sum
└── README.md
```

## Реализованные алгоритмы кэширования

### LRU Кэш (Least Recently Used)

Кэш LRU удаляет наименее недавно использованные элементы при достижении максимального объема кэша. Данная реализация использует:

- `container/list` для поддержания порядка использования
- `map[interface{}]*list.Element` для поиска за O(1)
- Двусвязный список для отслеживания порядка доступа

Основные особенности:
- O(1) по времени для операций Get и Add
- Автоматическое удаление наименее часто используемых элементов
- Реализация без поддержки многопоточности (предназначена для однопоточного использования)

### LFU Кэш (Least Frequently Used)

Кэш LFU удаляет наименее часто используемые элементы. Данная реализация использует более сложную структуру данных:

- Множество списков частот, организованных по количеству обращений
- Основной список узлов частот, отсортированный по частоте
- Хеш-таблицы для поиска за O(1)
- Поведение LRU в пределах одного уровня частоты

Основные особенности:
- Средняя сложность O(1) для операций Get и Put
- Эффективная обработка увеличения частоты
- Поддержание порядка LRU среди элементов с одинаковой частотой
- Автоматическое удаление наименее часто используемых элементов

## Использование

### Запуск примера

Основное приложение в файле `cmd/app/main.go` демонстрирует использование кэша LRU:

```go
func main() {
    cache := lru.NewLRUCache(2)
    log.Println(cache.Add("key1", "value1")) // true
    log.Println(cache.Add("key2", "value2")) // true
    log.Println(cache.Get("key1"))           // "value1", true
    log.Println(cache.Add("key3", "value3")) // true
    log.Println(cache.Get("key2"))           // "", false
}
```

### Использование кэшей

```go
// Создание кэша LRU с максимальным размером 100
lruCache := lru.NewLRUCache(100)

// Создание кэша LFU с максимальным размером 100
lfuCache := lfu.NewLFUCache(100)

// Базовые операции
lruCache.Add("key", "value")
value, exists := lruCache.Get("key")
removed := lruCache.Remove("key")
```

## Зависимости

- Go 1.18+
- `github.com/stretchr/testify` - для тестирования с утверждениями

## Тестирование

Проект включает модульные тесты для обоих алгоритмов кэширования в соответствующих каталогах. Запустите тесты с помощью команды:

```bash
  go test ./...
```

## Особенности проектирования

1. **Проектирование на основе интерфейсов**: Пакет cache определяет общий интерфейс для различных стратегий кэширования
2. **Эффективность использования памяти**: Используются хеш-таблицы и связные списки для оптимального использования памяти
3. **Производительность**: Все основные операции спроектированы для выполнения за O(1)
4. **Расширяемость**: Легко добавлять новые стратегии кэширования путем реализации интерфейса Cache

## Возможные улучшения

- Добавить поддержку многопоточности с использованием мьютексов или RWMutex
- Реализовать поддержку TTL (время жизни)
- Добавить сбор метрик (частота попаданий, частота промахов)
- Поддержка сериализации/десериализации
- Операции с учетом контекста для обработки тайм-аутов
